"""Property tests for UserSubscriptionManager.

This module contains property-based tests for the UserSubscriptionManager class,
verifying universal properties across many randomly generated inputs.
"""

import asyncio

from hypothesis import given, settings, strategies as st
import pytest

from spy_sma_alert_bot.services.user_subscription_manager import UserSubscriptionManager


# Feature: spy-sma-alert-bot, Property 3: User subscription registration
@settings(max_examples=100, deadline=None)
@given(chat_id=st.integers(min_value=1, max_value=999999999999))
def test_user_subscription_registration(chat_id: int) -> None:
    """Property test for user subscription registration.

    For any user ID, when the user sends the "/start" command, the user should be
    registered as subscribed and receive a confirmation message.

    Args:
        chat_id: Telegram chat ID (generated by Hypothesis)

    Validates: Requirements 2.1
    """

    async def run_test() -> None:
        manager = UserSubscriptionManager()

        # Initially, user should not be subscribed
        assert not await manager.is_subscribed(chat_id)

        # Subscribe the user
        result = await manager.subscribe_user(chat_id)

        # Should return True (successfully subscribed)
        assert result is True

        # User should now be subscribed
        assert await manager.is_subscribed(chat_id)

        # Should not be able to subscribe again (already subscribed)
        result = await manager.subscribe_user(chat_id)
        assert result is False

        # User should still be subscribed
        assert await manager.is_subscribed(chat_id)

    asyncio.run(run_test())


# Feature: spy-sma-alert-bot, Property 4: User subscription cancellation
@settings(max_examples=100, deadline=None)
@given(chat_id=st.integers(min_value=1, max_value=999999999999))
def test_user_subscription_cancellation(chat_id: int) -> None:
    """Property test for user subscription cancellation.

    For any subscribed user ID, when the user sends the "/stop" command, the user
    should be unregistered from subscriptions and receive a confirmation message.

    Args:
        chat_id: Telegram chat ID (generated by Hypothesis)

    Validates: Requirements 2.2
    """

    async def run_test() -> None:
        manager = UserSubscriptionManager()

        # Initially, user should not be subscribed
        assert not await manager.is_subscribed(chat_id)

        # Should not be able to unsubscribe (not subscribed)
        result = await manager.unsubscribe_user(chat_id)
        assert result is False

        # Subscribe the user
        await manager.subscribe_user(chat_id)
        assert await manager.is_subscribed(chat_id)

        # Unsubscribe the user
        result = await manager.unsubscribe_user(chat_id)

        # Should return True (successfully unsubscribed)
        assert result is True

        # User should no longer be subscribed
        assert not await manager.is_subscribed(chat_id)

        # Should not be able to unsubscribe again (already unsubscribed)
        result = await manager.unsubscribe_user(chat_id)
        assert result is False

        # User should still not be subscribed
        assert not await manager.is_subscribed(chat_id)

    asyncio.run(run_test())


# Feature: spy-sma-alert-bot, Property 3 & 4: Subscription state consistency
@settings(max_examples=50, deadline=None)
@given(
    chat_ids=st.lists(
        st.integers(min_value=1, max_value=999999999999),
        min_size=0,
        max_size=50,
        unique=True,
    )
)
def test_subscription_state_consistency(chat_ids: list[int]) -> None:
    """Property test for subscription state consistency.

    After subscribing and unsubscribing users, the state should be consistent
    across all operations.

    Args:
        chat_ids: List of unique chat IDs (generated by Hypothesis)

    Validates: Requirements 2.1, 2.2
    """

    async def run_test() -> None:
        manager = UserSubscriptionManager()

        # Initially, no users should be subscribed
        for chat_id in chat_ids:
            assert not await manager.is_subscribed(chat_id)

        # Subscribe all users
        subscribed_count = 0
        for chat_id in chat_ids:
            result = await manager.subscribe_user(chat_id)
            if result:  # Only count successful subscriptions
                subscribed_count += 1

        # Verify all users are subscribed
        for chat_id in chat_ids:
            is_subscribed = await manager.is_subscribed(chat_id)
            assert is_subscribed == (chat_id in chat_ids)

        # Verify subscriber count
        assert await manager.get_subscriber_count() == subscribed_count

        # Verify get_all_subscribers returns correct count
        all_subscribers = await manager.get_all_subscribers()
        assert len(all_subscribers) == subscribed_count

        # Unsubscribe all users
        for chat_id in chat_ids:
            if await manager.is_subscribed(chat_id):
                result = await manager.unsubscribe_user(chat_id)
                assert result is True

        # Verify no users are subscribed
        for chat_id in chat_ids:
            assert not await manager.is_subscribed(chat_id)

        # Verify subscriber count is zero
        assert await manager.get_subscriber_count() == 0

        # Verify get_all_subscribers returns empty list
        all_subscribers = await manager.get_all_subscribers()
        assert len(all_subscribers) == 0

    asyncio.run(run_test())


def test_user_subscription_edge_cases() -> None:
    """Test edge cases for user subscription management."""

    async def run_test() -> None:
        manager = UserSubscriptionManager()

        # Test with invalid chat IDs
        with pytest.raises(ValueError):
            await manager.subscribe_user(0)

        with pytest.raises(ValueError):
            await manager.subscribe_user(-1)

        with pytest.raises(ValueError):
            await manager.subscribe_user("invalid")  # type: ignore

        # Same for unsubscribe
        with pytest.raises(ValueError):
            await manager.unsubscribe_user(0)

        with pytest.raises(ValueError):
            await manager.unsubscribe_user(-1)

        # Test clear subscriptions
        await manager.subscribe_user(123)
        await manager.subscribe_user(456)
        assert await manager.get_subscriber_count() == 2

        await manager.clear_subscriptions()
        assert await manager.get_subscriber_count() == 0
        assert await manager.is_subscribed(123) is False
        assert await manager.is_subscribed(456) is False

    asyncio.run(run_test())


def test_concurrent_subscription_operations() -> None:
    """Test concurrent subscription operations to verify thread safety."""

    async def run_test() -> None:
        manager = UserSubscriptionManager()

        # Test concurrent subscriptions
        async def subscribe_task(chat_id: int) -> bool:
            return await manager.subscribe_user(chat_id)

        # Subscribe the same user from multiple coroutines
        tasks = [subscribe_task(123) for _ in range(10)]
        results = await asyncio.gather(*tasks)

        # Only one should succeed, others should fail (already subscribed)
        assert sum(results) == 1  # Exactly one True

        # User should be subscribed
        assert await manager.is_subscribed(123)

        # Test concurrent unsubscriptions
        async def unsubscribe_task(chat_id: int) -> bool:
            return await manager.unsubscribe_user(chat_id)

        # Try to unsubscribe the same user from multiple coroutines
        tasks = [unsubscribe_task(123) for _ in range(10)]
        results = await asyncio.gather(*tasks)

        # Only one should succeed, others should fail (already unsubscribed)
        assert sum(results) == 1  # Exactly one True

        # User should not be subscribed
        assert await manager.is_subscribed(123) is False

    asyncio.run(run_test())
